---
title: "Auswirkung abwesender Fraktionsmitglieder auf den Ausgang von Abstimmungen im Nationalrat"
author: "SRF Data, Pascal Burkhard (pascal.burkhard@srf.ch)"
date: "Februar 2018"
output:
  html_document:
    code_folding: show
    echo: TRUE
    warning: FALSE
    message: FALSE
    theme: simplex
    df_print: kable
    toc: yes
    toc_depth: 4
    toc_float: 
      collapsed: false
      smooth_scroll: false
subtitle: Vorprozessierung und Analyse
---

```{r, echo=FALSE}
project_name <- "2018-02-parlament-absenzen"
r_version <- "3.4.3"
```

## Vorbemerkungen

Dieses Dokument beschreibt die Vorprozessierung und explorative Analyse des Datensatzes, der Grundlage des auf srf.ch veröffentlichten Artikel [XYZ](http://www.srf.ch/data) ist.

SRF Data legt Wert darauf, dass die Datenvorprozessierung und -Analyse nachvollzogen und überprüft werden kann. SRF Data glaubt an das Prinzip offener Daten, aber auch offener und nachvollziehbarer Methoden. Zum anderen soll es Dritten ermöglicht werden, auf dieser Vorarbeit aufzubauen und damit weitere Auswertungen oder Applikationen zu generieren.  

Die Endprodukte des vorliegenden Scripts, neben der vorliegenden explorativen Analyse, sind folgende Files:

* `cases.xls`: Der Datensatz, der alle Fälle aufzeigt, bei denen Fraktionen Abstimmungen verloren, die sie hätten gewinnen können, wenn keine Fraktionsmitglieder gefehlt hätten. In diesem Datensatz kann eine bestimmte Abstimmung mehrfach vorkommen, wenn mehrere Fraktionen die Chance gehabt hätten, den Ausgang einer Abstimmung zu beeinflussen.
* `cases_unique.xls`: Der Datensatz weist jede der betroffenen Abstimmungen auf, unabhängig von und ohne Angabe zur betroffenen Fraktion.

### R-Script & Daten

Die Vorprozessierung und Analyse wurde im Statistikprogramm R vorgenommen. Das zugrunde liegende Script sowie die prozessierten Daten können unter [diesem Link](https://srfdata.github.io/`r project_name`/rscript.zip) heruntergeladen werden. Durch Ausführen von `main.Rmd` kann der hier beschriebene Prozess nachvollzogen und der für den Artikel verwendete Datensatz generiert werden. Dabei werden Daten aus dem Ordner `input` eingelesen und Ergebnisse in den Ordner `output` geschrieben. 

Verwendet wird **R Version `r r_version`**. Wenn der Code nicht funktioniert, könnte es daran liegen, dass die installierte R Version eine ältere ist und deshalb aus Kompatibilitätsgründen ältere Packages installiert werden, als die von uns verwendeten. Manchmal hilft es, das Skript mehrmals auszuführen, wenn ein Fehler auftritt. Besonders bei Package-Installationsproblemen kann es helfen, die R-Session mehrmals neuzustarten und den Code nochmals auszuführen. Allenfalls müssen noch Third-Party-Libraries wie z.B. `libgdal-dev` installiert werden.

### GitHub

Der Code für die vorliegende Datenprozessierung ist auf [https://github.com/srfdata/`r project_name`](https://github.com/srfdata/`r project_name`) zur freien Verwendung verfügbar. 

### Lizenz

<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons Lizenzvertrag" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br /><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Dataset" property="dct:title" rel="dct:type">`r project_name`</span> von <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/srfdata/`r project_name`" property="cc:attributionName" rel="cc:attributionURL">SRF Data</a> ist lizenziert unter einer <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Namensnennung - Weitergabe unter gleichen Bedingungen 4.0 International Lizenz</a>.

### Weitere Projekte

Code & Daten von [SRF Data](http://srf.ch/data) sind unter [http://srfdata.github.io](http://srfdata.github.io) verfügbar.

### Haftungsausschluss

Die veröffentlichten Informationen sind sorgfältig zusammengestellt, erheben aber keinen Anspruch auf Aktualität, Vollständigkeit oder Richtigkeit. Es wird keine Haftung übernommen für Schäden, die  durch die Verwendung dieses Scripts oder der daraus gezogenen Informationen entstehen. Dies gilt ebenfalls für Inhalte Dritter, die über dieses Angebot zugänglich sind.

### Originalquelle

Die Originalquelle ist die [Abstimmungsdatenbank des Parlamentsdienstes](https://www.parlament.ch/de/ratsbetrieb/abstimmungen/abstimmung-nr-xls) der Schweiz. Dort veröffentlicht der Parlamentsdienst Namenslisten mit dem Abstimmungsverhalten aller Mitglieder des Nationalrats seit Beginn der 49. Legislaturperiode.


## Vorbereitungen

```{r preparations, echo=FALSE}
detach_all_packages <- function() {
  basic_packages_blank <- c(
    "stats",
    "graphics",
    "grDevices",
    "utils",
    "datasets",
    "methods",
    "base"
  )
  basic_packages <- paste("package:", basic_packages_blank, sep = "")

  package_list <- search()[
    ifelse(unlist(gregexpr("package:", search())) == 1, TRUE, FALSE)
  ]

  package_list <- setdiff(package_list, basic_packages)

  if (length(package_list) > 0) {
    for (package in package_list) {
      detach(package, character.only = TRUE, unload = TRUE)
      print(paste("package ", package, " detached", sep = ""))
    }
  }
}

detach_all_packages()
source("scripts/csf.R")
path_to_wd <- csf() # if this - for some reason - does not work,
# replace with a hardcoded path, like so: "~/projects/rddj-template/analysis/"
if (is.null(path_to_wd) | !dir.exists(path_to_wd)) {
  stop("No working directory specified for current user")
} else {
  setwd(path_to_wd)
}

# E-Notation unterdrücken
options(scipen = 999)
```


### Packages definieren

```{r define packages}
# von https://mran.revolutionanalytics.com/web/packages/checkpoint/vignettes/using-checkpoint-with-knitr.html
# alle Packages, die nicht gebraucht werden,
# können hier entfernt werden (auskommentieren reicht nicht!)
# Wichtig: wenn neues Package installiert werden soll,
# scanForPackages = T setzen im checkpoint() call im nächsten Chunk
# tidyverse: see https://blog.rstudio.org/2016/09/15/tidyverse-1-0-0/
cat(
  "
library(rstudioapi) # temporary bugfix, might be removed when renewing date
library(tidyverse) # ggplot2, dplyr, tidyr, readr, purrr, tibble
library(magrittr) # pipes
library(stringr) # string manipulation
library(readxl) # excel
library(WriteXLS) #write excel
library(scales) # scales for ggplot2
library(jsonlite) # json
library(forcats) # easier factor handling,
library(lintr) # code linting, auf keinen Fall entfernen ;-)
library(styler) # code formatting
library(rmarkdown) # muss für automatisches knitting 
# in deploy.sh eingebunden werden",
  file = "manifest.R"
)
package_date <- "2018-01-01"
```

### Packages installieren

```{r install packages}
if (!require(checkpoint)) {
  if (!require(devtools)) {
    install.packages("devtools", repos = "http://cran.us.r-project.org")
    require(devtools)
  }
  devtools::install_github(
    "checkpoint",
    username = "RevolutionAnalytics",
    ref = "v0.3.2",
    repos = "http://cran.us.r-project.org"
  )
  require(checkpoint)
}
# nolint start
if (!dir.exists("~/.checkpoint")) {
  dir.create("~/.checkpoint")
}
# nolint end
checkpoint(
  snapshotDate = package_date,
  project = path_to_wd,
  verbose = T,
  scanForPackages = T, # hier ggf. auf T setzen, s.o.
  use.knitr = F,
  R.version = r_version
) # wenn eine "ähnliche" Version von R
# installiert ist (3.4.3 in diesem Fall), kann dieses
# Argument hier entfernt und die vorhandene R-Version
# verwendet werden - vorausgesetzt, die hier verwendeten
# Packages funktionieren mit dieser.
rm(package_date, r_version)
```


### Packages laden

```{r load packages}
source("manifest.R")
unlink("manifest.R")
sessionInfo()
rm(list = ls(all.names = TRUE))
```

### Zusätzliche Scripts laden

```{r load scripts}
# falls Logik auf andere Scripts ausgelagert werden soll (z.B. der Übersichtlichkeit halber), hier einkommentieren
```

## Vorprozessierung der Daten

### Daten einlesen und transformieren

Für jede Abstimmung im Nationalrat liegen Daten zum Abstimmungsverhalten der einzelnen Ratsmitglieder vor. Der Parlamentsdienst stellt die Daten sessionsweise als xlsx-Dateien zur Verfügung. Daraus sollen die oben beschriebenen Datensätze erstellt werden.


```{r}
# Leere Datensätze erstellen, um mit dem Loop aufzufüllen
cases <- data.frame()
abstimmungen <- data.frame()
parlamentarier <- data.frame()

# Loop, der die einzelnen xlsx-Files jeder Session einliest und verarbeitet
temp <- list.files(
  path = "input",
  pattern = "*.xlsx"
)

# Beginn des Loops
for (i in temp) {
  
  # Schritt 1: Abstimmung und Abstimmungsverhalten der Parlamentarier einlesen und zu einem Datensatz zusammenfassen

  # xlsx-Dateien zu Abstimmungen einlesen und Bereich auswählen
  votes_loop <- read_excel(
    paste(
      "input/",
      i,
      sep = ""
    ),
    col_names = TRUE,
    range = anchored("A9", dim = c(NA, NA))
  )
  
  # Zur einfacheren Verarbeitung nur das Datum der Abstimmungen speichern
  votes_loop %<>%
    mutate(VoteDate = str_sub(VoteDate, 0, 10))

  # Liste aller Abstimmungen wird bei jedem Durchgang des Loops ergänzt
  abstimmungen %<>% 
    bind_rows(
      select(votes_loop, 
             VoteDate:VoteSubmissionText, 
             Decision:Präsident) 
      )
  # Transformieren des Datensatzes, alle Parlamentarier und Abstimmungen einzeln auflisten
  votes_loop %<>%
    gather(
      BioId,
      VoteDecision,
      13:(ncol(votes_loop) - 7)
    )
  
  
  # Schritt 2: Ein Datensatz aller Parlamentarier erstellen

  # xlsx-Dateien zu Parlamentariern einlesen, Bereich auswählen und neu benennen
  parl_loop <-
      read_excel(
        paste(
          "input/",
          i,
          sep = ""
          ),
        col_names = F,
        range = anchored("M1", dim = c(8, NA))
        )

    parl_loop %<>%
      t() %>%
      as.data.frame() %>%
      rename(
        Id = V1,
        BioId = V2,
        CouncillorName = V3,
        Rat = V4,
        Fraktion = V5,
        Kanton = V6,
        Geburtsdatum = V7,
        Vereidigungsdatum = V8) %>%
      mutate(BioId = as.character(BioId),
             Id = as.character(Id),
             CouncillorName = as.character(CouncillorName),
             Geburtsdatum = as.character(Geburtsdatum),
             Vereidigungsdatum = as.character(Vereidigungsdatum),
             Fraktion = as.character(Fraktion))

  # Datensatz aller Parlamentarier wird bei jedem Durchgang des Loops ergänzt
   parlamentarier %<>%
    bind_rows(
      parl_loop)


  # Schritt 3: Das Abstimmungsverhalten der Fraktionen zu jeder einzelnen Abstimmung berechnen Datensatz zu Abstimmungen und Parlamentarieren mergen und anpassen
  data_merged <-
    full_join(
    votes_loop,
    parl_loop,
    by = "BioId"
  )

  # Datensatz spezifieren, rekodieren und Abstimmungen nach Fraktionen gruppieren
  data_merged %<>%
    select(
      BioId,
      Id,
      Name = CouncillorName,
      Rat = Rat.x,
      Fraktion,
      Kanton,
      Date = VoteDate,
      Kommission,
      Dept.,
      AffairId,
      AffairTitle,
      VoteId = VoteRegistrationNumber,
      VoteMeaningYes,
      VoteMeaningNo,
      DivisionText,
      SubmissionText = VoteSubmissionText,
      VoteDecision,
      RatJa = Ja,
      RatNein = Nein,
      RatEnth = `Enth.`,
      RatEntsch = `Entschuldigung gem. Art. 57 Abs. 4`,
      RatNicht = `Hat nicht teilgenommen`,
      RatPres = Präsident) %>%
    mutate(Ja = case_when(VoteDecision ==
                            "Ja" ~ 1, TRUE ~ 0),
           Nein = case_when(VoteDecision ==
                              "Nein" ~ 1, TRUE ~ 0),
           Ent = case_when(VoteDecision ==
                             "Enthaltung" ~ 1, TRUE ~ 0),
           Abw = case_when(VoteDecision ==
                             "Hat nicht teilgenommen" ~ 1, TRUE ~ 0),
           AbwEnt = case_when(VoteDecision ==
                                "Entschuldigt" ~ 1, TRUE ~ 0),
           Pres = case_when(VoteDecision ==
                              "Der Präsident stimmt nicht" ~ 1, TRUE ~ 0)) %>%
    group_by(VoteId, Fraktion) %>%
    summarise(
      Ja = sum(Ja),
      Nein = sum(Nein),
      Enthaltung = sum(Ent),
      Abwesend = sum(Abw),
      Entschuldigt = sum(AbwEnt),
      Präsident = sum(Pres),
      RatJa = mean(RatJa),
      RatNein = mean(RatNein),
      RatEnthaltung = mean(RatEnth),
      RatEntschuldigt = mean(RatEntsch),
      RatAbwesend = mean(RatNicht)
    )


  # Schritt 4: Potenzial berechnen, um die für die Auswertung relevanten Fälle zu finden

  # Das Potenzial A ist die Differenz zwischen der Anzahl der fehlenden Personen einer Fraktion und der Stimmendifferenz im Rat. Das Potenzial gibt darüber Auskunft, ob eine Fraktion eine Abstimmung hätte gewinnen können, wenn alle Mitglieder anwesend gewesen wären. In der Regel trifft dies zu für Fraktionen und Abstimmungen mit einem Potenzial A > 0. Allerdings gibt es 2 Ausnahmen, bei denen auch Potenzial A = 0 ausreicht. Aus diesem Grund werden vorerst auch diese Fälle mitberücksichtigt. (Wird später für die Berechnung von Potenzial B und Potenzial C relevant.)

  # Berechnen, wie eine Abstimmungen aus Sicht der Fraktionsmehrheit ausging
  data_merged %<>%
    mutate(RatDifferenz = RatJa - RatNein,
           Fehlende = Abwesend, #+ Entschuldigt,
           PotentialA = Fehlende - abs(RatDifferenz)) %>%
    mutate(Ausgang = ( Ja / ( Ja + Nein ) - 0.5 ) /
             ( RatJa / ( RatJa + RatNein )  - 0.5 ) ) %>%
    mutate(Ausgang = case_when(Ausgang <= 0 ~ "Verloren",
                               TRUE ~ "Gewonnen")) %>%
    filter(PotentialA > -1 &
             Ausgang == "Verloren")

  # Fälle, in denen das Potenzial A mindestens 0 beträg und die Abstimmung aus Sicht der Fraktionsmehr verloren wurde, an den Datensatz "cases" anhängen
  cases %<>%
    bind_rows(data_merged)
}

# Nicht weiter benötigte Datensätze löschen
rm(data_merged)
rm(votes_loop)
rm(parl_loop)

# Rekodieren der CVP-Fraktion
cases %<>% 
  mutate(Fraktion = recode(Fraktion, "CE" = "C"))

# Jeden Parlamentarier nur einmal im Datensatz
parlamentarier %<>% 
  distinct(BioId, .keep_all = T)
```



### Spezialfälle berechnen

Eine Abstimmungen gilt dann als verschenkt, wenn die Anzahl der Abwesenden einer Fraktion grösser ist als die totale Stimmendifferenz (d.h. "Potenzial A" > 0). Wie bereits erwähnt, gibt es aber zwei Ausnahmen:


#### 1. Abstimmungen mit Stichentscheid

Abstimmungen, bei denen der Präsident aufgrund von Stimmengleichheit im Rat den Stichentscheid fällt. Ist die Anzahl der Abwesenden in diesem Fall gleich gross wie die totale Stimmendifferenz ("Potenzial A" = 0), gilt die Abstimmung dennoch als verschenkt. Obwohl die Stimmendifferenz = 1, hätte 1 zusätzliches Fraktionsmitglied schon gereicht, um die Abstimmung zu gewinnen (da der Präsident dann nicht mitgestimmt hätte). Für diese Fälle gilt "Potenzial B" = 1. 


```{r}
# Dazu wird zuerst berechnet, in welchen Abstimmungen der Präsident den Stichentscheid fällte. (Der Präsident kann bei einer Reihe von besonderen Abstimmungen mitstimmen, nicht nur wenn im Rat Stimmenparität herrscht. Weil wir aber nur die Stichentscheide wollen, suchen wir also all jene Entscheide, bei denen der Präsident mitstimmte und die Stimmendifferenz 1 beträgt.)

abstimmungen %<>%
  mutate(Differenz = Ja - Nein)

# Subset erstellen für Abstimmungen, die der Präsident per Stichentscheid entschied
abstimmungen_pres <- abstimmungen %>%
  select(
    Dept.,
    AffairId,
    VoteRegistrationNumber,
    Ja,
    Nein,
    Differenz,
    Präsident
  )

abstimmungen_pres %<>% 
  mutate(Differenz = abs(Differenz))

abstimmungen_pres %<>% 
  filter(Differenz == 1 &
           Präsident == "True") %>%
  select(
    VoteRegistrationNumber,
    PresDec = Präsident
  )

# In einer neuen Variable PotentialB wird vermerkt, ob ein Stichentscheid des Präsidenten stattfand
cases %<>% 
  left_join(
    abstimmungen_pres,
    by = c("VoteId" = "VoteRegistrationNumber")) %>%
  mutate(PotentialB = case_when(PresDec == "True" &
                               PotentialA == 0  ~ 1, 
                               TRUE ~ 0))
rm(abstimmungen_pres)
```

#### 2. Fraktionszugehörigkeit des NR-Präsidenten

Ein weiterer Spezialfall sind Abstimmungen, bei denen die Anzahl der Abwesenden einer Fraktion gleich gross ist wie die totale Stimmendifferenz (d.h. "Potenzial A" = 0) und der NR-Präsident der eigenen Fraktion angehört. Wären in diesem Fall alle Fraktionsteilnehmer anwesend, entschiede der Präsident per Stichentscheid. Da dieser der eigenen Fraktion angehört, wird davon ausgegangen, dass er ebenfalls im Sinne der Fraktionsmehrheit stimmt. In diesem Fall gilt "Potenzial C" = 1.

```{r}
# Diese Fälle werden in der Variable PotentialC vermerkt.
cases %<>%
  mutate(PotentialC = case_when(Präsident == 1  ~ 1, 
                               TRUE ~ 0))
```

### Spezialfälle berücksichtigen

Erst die Variable PotentialTotal beinhaltet alle Spezialfälle. Weist eine Abstimmung für eine Fraktion also eine Gesamtpotenzial von mind. 1 auf, gilt die Abstimmung als verschenkte Chance. Es können also alle Abstimmungen und Fraktionen entfernt werden, bei denen das PotentialTotal 0 oder kleiner ist. 

```{r}
# Variable PotentialTotal berechnen und berücksichtigen
cases %<>%
  mutate(PotentialTotal = 
           PotentialA + 
           PotentialB + 
           PotentialC) %>%
  filter(PotentialTotal > 0)
```

### Datensatz vereinheitlichen

```{r}
# Datensatz zu "verschenkten Abstimmungen" mit Zusatzdaten zu Abstimmungen (Titel, Text, etc.) kombinieren
abstimmungen_t <- abstimmungen %>%
  select(
    Date = VoteDate,
    Kommission,
    Dept = `Dept.`,
    `AffairId`,
    Title = AffairTitle,
    VoteMeaningYes,
    VoteMeaningNo,
    DivisionText,
    VoteSubmissionText,
    VoteId = VoteRegistrationNumber
  )

cases %<>% left_join(
  abstimmungen_t,
  by = "VoteId"
)
rm(abstimmungen_t)

# Umbrüche entfernen
cases %<>%
  mutate(Title = str_replace_all(Title, "[\r\n]", " "),
         VoteMeaningYes = str_replace_all(VoteMeaningYes, "[\r\n]", " "),
         VoteMeaningNo = str_replace_all(VoteMeaningNo, "[\r\n]", " "),
         DivisionText = str_replace_all(DivisionText, "[\r\n]", " "),
         VoteSubmissionText = str_replace_all(VoteSubmissionText, "[\r\n]", 
                                              " "))
```

### Threshold für Einigkeit

Die Analyse basiert auf der Annahme, dass die abwesenden Parlamentarier gleich stimmen wie die Mehrheit der anwesenden Fraktionsmitglieder. Diese Annahme ist aber nur realistisch, wenn es in der Fraktion klare Mehrheitsverhältnisse gibt. Mit dem Threshold wird festgelegt, wie gross die Mehrheit in Prozent mindestens sein soll, damit der Fall in der Analyse berücksichtigt wird. 

```{r}
# Der Threshold wird bei 75% angelegt.
ts1 <- 75
cases %<>%
  mutate(JaAnteil = Ja / (Ja + Nein)) %>%
  filter(JaAnteil > (ts1 / 100) | 
           JaAnteil < (100 - ts1) / 100)
```

Es gibt auch Fälle, wo sich ein Teil der Fraktion der Stimme enthält. Je grösser der Anteil der anwesenden Fraktionsmitglieder, der sich einer Stimme enthält, desto unwahrscheinlicher wird die Annahme, dass die abwesendenen Mitglieder mit der stimmenden Fraktionsmehrheit gestimmt hätten. Vielmehr hätten wohl auch sie sich ihrer Stimme enthalten. Deshalb wird ein Threshold gesetzt, der bestimmt, wie gross der Anteil der Enthaltungen maximal sein darf, bevor eine Abstimmung nicht mehr berücksichtigt wird.  


```{r}
# Der Threshold wird bei 25% angelegt.
ts2 <- 25
cases %<>%
  mutate(EnthAnteil = Enthaltung / (Ja + Nein + Enthaltung)) %>%
  filter(EnthAnteil < ( ts2 / 100) )
```


### Datensätze speichern

```{r}
# Das File "cases.xls" enthält alle Fälle, in denen Fraktionen wegen Schwänzern Abstimmungen verloren, die sie eigentlich hätten gewinnen können (inkl. Link zum offiziellem Abstimmungsprotokoll).
cases %<>%
  mutate(legislatur = case_when(VoteId < 12604 ~ 49,
                                VoteId >= 12604 ~ 50)) %>%
  mutate(URL = paste(
    "https://www.parlament.ch/poly/Abstimmung/",
    legislatur,
    "/out/vote_",
    legislatur,
    "_",
    VoteId,
    ".pdf",
    sep = ""))
  
WriteXLS(
  cases,
  ExcelFileName = "output/cases.xls"
)

# Das File "cases_unique.xls" enthält alle Abstimmungen, die anders ausgegangen wären, wenn eine der unterlegenen Fraktionen vollständig anwesend gewesen wäre.
cases_unique <-
  cases %>% 
  distinct(VoteId, .keep_all = T)

cases_unique %<>% 
  select(
    Date:VoteSubmissionText,
    VoteId,
    RatJa:Fehlende)

WriteXLS(
  cases_unique,
  ExcelFileName = "output/cases_unique.xls"
) # alle betroffenen Abstimmungen
```


## Plots

Ein paar einfache Plots als Überblick über die Daten.

### Plot: "Verlorene Abstimmungen wegen abwesenden Fraktionsmitgliedern""

```{r}
plot <- ggplot(cases, aes(Fraktion)) +
  geom_histogram(stat = "count") +
  labs(
    x = "Fraktion",
    y = "Anzahl",
    title = "Verlorene Abstimmungen wegen abwesenden Fraktionsmitgliedern"
  ) +
  theme_minimal()
plot
```

### Plot: "SVP: Verschenkte Abstimmungen nach Departement"

```{r}
dplot <- filter(cases, Fraktion == "V")
plot <- ggplot(dplot, aes(Dept)) +
  geom_histogram(stat = "count") +
  labs(
    x = "Dept.",
    y = "Anzahl",
    title = "SVP: Verschenkte Abstimmungen nach Departement"
  ) +
  theme_minimal()
plot
rm(dplot)
```

### Plot: "SP: Verschenkte Abstimmungen nach Departement"

```{r}
dplot <- filter(cases, Fraktion == "S")
plot <- ggplot(dplot, aes(Dept)) +
  geom_histogram(stat = "count") +
  labs(
    x = "Dept.",
    y = "Anzahl",
    title = "SP: Verschenkte Abstimmungen nach Departement"
  ) +
  theme_minimal()
plot
rm(dplot)
```

### Plot: "Verschenkte Abstimmungen nach Art der Vorlage"

```{r}
dplot <- 
  cases %>% 
  distinct(VoteId, .keep_all = T)

dplot %<>%
  mutate(differenz = (RatJa - RatNein),
         form = case_when(grepl("Motion", 
                                VoteMeaningYes, 
                                ignore.case = T) ~ "Motion",
                          grepl("Postulat", 
                                VoteMeaningYes, 
                                ignore.case = T) ~ "Postulat",
                          grepl("Gesamtabstimmung", 
                                DivisionText,
                                ignore.case = T) ~ "Gesamtabstimmung"))

plot <- ggplot(dplot, aes(form)) +
  geom_histogram(stat = "count") +
  labs(
    x = "Art der Vorlage",
    y = "Anzahl",
    title = "Verschenkte Abstimmungen nach Art der Vorlage"
  ) +
  theme_minimal()
plot
rm(dplot)
```

### Plot: "Verschenkte Abstimmungen nach Jahr"

```{r}
dplot <- 
  cases %>% 
  distinct(VoteId, .keep_all = T)

dplot %<>%
  mutate(Date = str_sub(Date, 0, 4))

plot <- ggplot(dplot, aes(Date)) +
  geom_histogram(stat = "count") +
  labs(
    x = "Jahr",
    y = "Anzahl",
    title = "Verschenkte Abstimmungen nach Jahr"
  ) +
  theme_minimal()
plot
```


## Linting

Der Code in diesem RMarkdown wird mit [lintr](https://github.com/jimhester/lintr) automatisch auf den Wickham'schen [tidyverse style guide](http://style.tidyverse.org/) überprüft. 

```{r linting}
lintr::lint(
  "main.Rmd", linters =
    lintr::with_defaults(
      commented_code_linter = NULL,
      trailing_whitespace_linter = NULL
    )
)
# lintr::lint("scripts/my_script.R", linters =
#               lintr::with_defaults(
#                 commented_code_linter = NULL,
#                 trailing_whitespace_linter = NULL
#                 )
#             )
```

